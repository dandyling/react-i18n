import{createElement as e,createContext as n,useContext as t,useState as r,useEffect as o,useCallback as a,forwardRef as s}from"react";const l=(e,n)=>{const t=[];let r;const o=RegExp(e,"g");for(;null!==(r=o.exec(n));)t.push({offsets:[r.index,r.index+r[0].length],array:r});return t},c=(e,n)=>e.match.offsets[0]-n.match.offsets[0],u=(e,n)=>{if(!n.length)return[e];const t=[],r=[];let o=e;if(n.forEach(e=>{l(e.pattern,o).forEach(n=>{const t=Array.from({length:n.array[0].length}).map(()=>" ").join("");o=o.replace(n.array[0],t),r.push({match:n,rule:e})})}),o===e)return[e];o=e;let a=0;return r.sort(c).forEach((e,n)=>{const[s,l]=e.match.offsets,c=o.substring(a,s);if(c&&t.push(c),t.push(e.rule.onMatch(e.match.array)),a=l,n+1===r.length){const e=o.substring(a);e&&t.push(e)}}),t},h={pattern:/(\*\*|__)(.*?)\1/,onMatch:n=>e("strong",null,n[2])},i={pattern:/(\*|_)(.*?)\1/,onMatch:n=>e("em",null,n[2])},f={pattern:/~~(.*?)~~/,onMatch:n=>e("del",null,n[1])},g={pattern:/`(.*?)`/,onMatch:n=>e("code",null,n[1])},m={pattern:/\[([^\[]+)\]\(([^\)]+)\)/,onMatch:n=>e("a",{href:n[2]},n[1])},d=[h,i,g,m,f],p=n(void 0),b=()=>t(p),w=n=>{const{bundles:t,children:s,markdownRules:l,lang:c}=n,u=b();let h,i,f={},g=[];u&&(f=u.bundle,h=u.lang,i=u.resolveLanguageBundle,g=u.markdownRules);const m=(l||[]).filter(e=>!g.includes(e)).concat(g),[d,w]=r(),y=c||h;if(!y)throw Error("No `lang` prop specified");o(()=>{w(void 0)},[n.lang]);const j=a(e=>Promise.all([new Promise(n=>{f&&e===h?n(f):i?i(y).then(n):n({})}),new Promise(n=>{t&&t[e]?t[e]().then(n):n({})})]).then(e=>{let n={};return e.forEach(e=>{n=Object.assign(Object.assign({},n),e)}),n}),[y,h,f,t,i]);return o(()=>{d||j(y).then(w)},[d,y,f,t,j]),d?e(p.Provider,{value:{resolveLanguageBundle:j,lang:y,bundle:d,markdownRules:m}},s):null};function y(n,t){return s((r,o)=>{const{bundle:a,markdownRules:s}=b();let l=r;if(a&&r[t]){const e=r[t];let n="";if(e.constructor===Array){const[t,...r]=e;a[t]&&(n=a[t](...r))}else n=a[e],n||console.warn("No i18n value found for key: "+e);n&&(n=u(n,s),l=Object.assign(Object.assign({},r),{children:n}))}return e(n,Object.assign({},l,{ref:o}))})}w.defaultProps={markdownRules:d};const j=(e,n,t)=>new Intl.DateTimeFormat(t,n).format(e),v=(e,n,t={style:"currency"},r)=>new Intl.NumberFormat(r,Object.assign(Object.assign({},t),{currency:n})).format(e),E=(e,n,t,r)=>{const o=new Intl.PluralRules(r).select(e);switch(o){case"one":return`${e} ${n}`;case"other":return`${e} ${t}`}throw Error(`Unable to match ${o}.`)};export{h as BoldRule,d as DefaultMarkdownRules,w as I18NProvider,g as InlineCodeRule,i as ItalicRule,m as LinkRule,f as StrikethroughRule,l as findRegex,v as formatCurrency,j as formatDate,E as pluralize,u as transform,b as useI18N,y as withI18N};
